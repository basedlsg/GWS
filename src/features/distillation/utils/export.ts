/**
 * Task Export Utilities
 * Handle exporting tasks to various formats
 */

import type { Task, DistillationSession } from '../types';

/**
 * Export tasks as Markdown
 */
export function exportTasksAsMarkdown(session: DistillationSession): string {
  const { goal, tasks, createdAt, usedAI, persona } = session;

  let markdown = `# ${goal}\n\n`;
  markdown += `**Created:** ${new Date(createdAt).toLocaleString()}\n`;
  markdown += `**Persona:** ${persona}\n`;
  markdown += `**Generated with:** ${usedAI ? 'AI (Gemini)' : 'Template-based fallback'}\n`;
  markdown += `**Progress:** ${session.completedTaskCount}/${session.totalTaskCount} tasks completed\n\n`;

  markdown += `---\n\n`;

  // Group by priority
  const highPriority = tasks.filter((t) => t.priority === 'high');
  const mediumPriority = tasks.filter((t) => t.priority === 'medium');
  const lowPriority = tasks.filter((t) => t.priority === 'low');

  if (highPriority.length > 0) {
    markdown += `## ðŸ”´ High Priority\n\n`;
    markdown += formatTaskList(highPriority);
  }

  if (mediumPriority.length > 0) {
    markdown += `## ðŸŸ¡ Medium Priority\n\n`;
    markdown += formatTaskList(mediumPriority);
  }

  if (lowPriority.length > 0) {
    markdown += `## ðŸ”µ Low Priority\n\n`;
    markdown += formatTaskList(lowPriority);
  }

  markdown += `\n---\n\n`;
  markdown += `*Generated by The Great Work Suite - Distillation*\n`;

  return markdown;
}

/**
 * Format a list of tasks as markdown
 */
function formatTaskList(tasks: Task[]): string {
  return tasks
    .map((task) => {
      const checkbox = task.status === 'completed' ? '[x]' : '[ ]';
      const inProgress = task.status === 'in_progress' ? ' **(in progress)**' : '';
      return `- ${checkbox} ${task.text}${inProgress}\n`;
    })
    .join('');
}

/**
 * Export tasks as JSON
 */
export function exportTasksAsJSON(session: DistillationSession): string {
  return JSON.stringify(session, null, 2);
}

/**
 * Export tasks as plain text
 */
export function exportTasksAsText(session: DistillationSession): string {
  const { goal, tasks, createdAt, usedAI, persona } = session;

  let text = `${goal.toUpperCase()}\n`;
  text += `${'='.repeat(goal.length)}\n\n`;
  text += `Created: ${new Date(createdAt).toLocaleString()}\n`;
  text += `Persona: ${persona}\n`;
  text += `Generated with: ${usedAI ? 'AI (Gemini)' : 'Template-based fallback'}\n`;
  text += `Progress: ${session.completedTaskCount}/${session.totalTaskCount} tasks completed\n\n`;

  text += `${'-'.repeat(60)}\n\n`;

  // Group by status
  const pending = tasks.filter((t) => t.status === 'pending');
  const inProgress = tasks.filter((t) => t.status === 'in_progress');
  const completed = tasks.filter((t) => t.status === 'completed');

  if (inProgress.length > 0) {
    text += `IN PROGRESS:\n`;
    inProgress.forEach((task, index) => {
      text += `  ${index + 1}. [${task.priority.toUpperCase()}] ${task.text}\n`;
    });
    text += `\n`;
  }

  if (pending.length > 0) {
    text += `TODO:\n`;
    pending.forEach((task, index) => {
      text += `  ${index + 1}. [${task.priority.toUpperCase()}] ${task.text}\n`;
    });
    text += `\n`;
  }

  if (completed.length > 0) {
    text += `COMPLETED:\n`;
    completed.forEach((task, index) => {
      text += `  ${index + 1}. âœ“ ${task.text}\n`;
    });
    text += `\n`;
  }

  text += `${'-'.repeat(60)}\n\n`;
  text += `Generated by The Great Work Suite - Distillation\n`;

  return text;
}

/**
 * Export tasks as CSV
 */
export function exportTasksAsCSV(session: DistillationSession): string {
  const { tasks } = session;

  let csv = 'Status,Priority,Task,Created,Completed\n';

  tasks.forEach((task) => {
    const status = task.status;
    const priority = task.priority;
    const text = `"${task.text.replace(/"/g, '""')}"`;
    const created = new Date(task.createdAt).toLocaleString();
    const completed = task.completedAt ? new Date(task.completedAt).toLocaleString() : '';

    csv += `${status},${priority},${text},${created},${completed}\n`;
  });

  return csv;
}

/**
 * Download content as file
 */
export function downloadFile(content: string, filename: string, mimeType: string): void {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = sanitizeFilename(filename);
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Copy to clipboard
 */
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
}

/**
 * Sanitize filename for download
 */
function sanitizeFilename(filename: string): string {
  return filename
    .replace(/[^a-z0-9_\-\.]/gi, '_')
    .replace(/_+/g, '_')
    .substring(0, 100);
}
