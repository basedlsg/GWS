/**
 * Export Utilities
 * Handle exporting transmutations to various formats
 */

import type { TransmuteTheme } from '../types';
import { THEMES } from '../constants';
import { highlightText, generateThemeCSS } from './syntax';

/**
 * Generate standalone HTML for a transmutation
 */
export function generateHTML(text: string, language: string, theme: TransmuteTheme, title: string): string {
  const highlighted = highlightText(text, language, theme);
  const themeConfig = THEMES[theme];
  const css = generateThemeCSS(theme);

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHTML(title)}</title>
  <style>
    body {
      margin: 0;
      padding: 2rem;
      background-color: #1a1a1a;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    .header {
      margin-bottom: 2rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid ${themeConfig?.borderColor || '#333'};
    }

    .header h1 {
      margin: 0 0 0.5rem 0;
      color: ${themeConfig?.textColor || '#fff'};
      font-size: 2rem;
    }

    .header .meta {
      color: ${themeConfig?.secondaryColor || '#999'};
      font-size: 0.875rem;
    }

    ${css}

    .footer {
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 2px solid ${themeConfig?.borderColor || '#333'};
      text-align: center;
      color: ${themeConfig?.secondaryColor || '#999'};
      font-size: 0.875rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>${escapeHTML(title)}</h1>
      <div class="meta">
        Theme: ${themeConfig?.displayName || theme} • Language: ${language} • Generated: ${new Date().toLocaleString()}
      </div>
    </div>

    <div class="transmute-preview">
      <pre>${highlighted}</pre>
    </div>

    <div class="footer">
      Generated by The Great Work Suite - Transmute
    </div>
  </div>
</body>
</html>`;
}

/**
 * Copy HTML to clipboard
 */
export async function copyHTMLToClipboard(html: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(html);
    return true;
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
}

/**
 * Copy plain text to clipboard
 */
export async function copyTextToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
}

/**
 * Download HTML file
 */
export function downloadHTML(html: string, filename: string): void {
  const blob = new Blob([html], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${sanitizeFilename(filename)}.html`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Generate and download PNG (using html2canvas concept - simplified for now)
 * Note: For actual PNG export, you'd need html2canvas library
 */
export async function downloadPNG(
  elementId: string,
  _filename: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const element = document.getElementById(elementId);

    if (!element) {
      return { success: false, error: 'Element not found' };
    }

    // Check if html2canvas is available (would need to be installed)
    // For now, we'll return a helpful message
    return {
      success: false,
      error: 'PNG export requires html2canvas library (install with: npm install html2canvas)',
    };

    // Actual implementation would be:
    // const html2canvas = (await import('html2canvas')).default;
    // const canvas = await html2canvas(element);
    // const blob = await new Promise<Blob>((resolve) => canvas.toBlob(resolve as any));
    // const url = URL.createObjectURL(blob);
    // const a = document.createElement('a');
    // a.href = url;
    // a.download = `${sanitizeFilename(filename)}.png`;
    // document.body.appendChild(a);
    // a.click();
    // document.body.removeChild(a);
    // URL.revokeObjectURL(url);
    // return { success: true };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Generate markdown with code block
 */
export function generateMarkdown(text: string, language: string, title: string): string {
  return `# ${title}

\`\`\`${language}
${text}
\`\`\`

---
*Generated by The Great Work Suite - Transmute on ${new Date().toLocaleString()}*
`;
}

/**
 * Download markdown file
 */
export function downloadMarkdown(markdown: string, filename: string): void {
  const blob = new Blob([markdown], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${sanitizeFilename(filename)}.md`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Escape HTML special characters
 */
function escapeHTML(str: string): string {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

/**
 * Sanitize filename for download
 */
function sanitizeFilename(filename: string): string {
  return filename
    .replace(/[^a-z0-9_\-]/gi, '_')
    .replace(/_+/g, '_')
    .substring(0, 100);
}
